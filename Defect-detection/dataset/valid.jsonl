{"project": "qemu", "commit_id": "aa1530dec499f7525d2ccaa0e3a876dc8089ed1e", "target": 1, "func": "static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n{\n    MirrorState *s = FILTER_MIRROR(nf);\n    Chardev *chr;\n    chr = qemu_chr_find(s->outdev);\n    if (chr == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", s->outdev);\n    qemu_chr_fe_init(&s->chr_out, chr, errp);", "idx": 8}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int64_t sub64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a - b;\n\n}\n", "idx": 10}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                         void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    assert(key & FW_CFG_WRITE_CHANNEL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n}\n", "idx": 15}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static void emulated_push_error(EmulatedState *card, uint64_t code)\n\n{\n\n    EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent));\n\n\n\n    assert(event);\n\n    event->p.error.type = EMUL_ERROR;\n\n    event->p.error.code = code;\n\n    emulated_push_event(card, event);\n\n}\n", "idx": 22}
{"project": "qemu", "commit_id": "c39ce112b60ffafbaf700853e32bea74cbb2c148", "target": 0, "func": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n", "idx": 51}
{"project": "qemu", "commit_id": "d4a63ac8b19eb208465f27fde63f3cff7018fdfd", "target": 0, "func": "static void rtas_ibm_change_msi(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                                uint32_t token, uint32_t nargs,\n\n                                target_ulong args, uint32_t nret,\n\n                                target_ulong rets)\n\n{\n\n    uint32_t config_addr = rtas_ld(args, 0);\n\n    uint64_t buid = rtas_ldq(args, 1);\n\n    unsigned int func = rtas_ld(args, 3);\n\n    unsigned int req_num = rtas_ld(args, 4); /* 0 == remove all */\n\n    unsigned int seq_num = rtas_ld(args, 5);\n\n    unsigned int ret_intr_type;\n\n    unsigned int irq, max_irqs = 0, num = 0;\n\n    sPAPRPHBState *phb = NULL;\n\n    PCIDevice *pdev = NULL;\n\n    spapr_pci_msi *msi;\n\n    int *config_addr_key;\n\n\n\n    switch (func) {\n\n    case RTAS_CHANGE_MSI_FN:\n\n    case RTAS_CHANGE_FN:\n\n        ret_intr_type = RTAS_TYPE_MSI;\n\n        break;\n\n    case RTAS_CHANGE_MSIX_FN:\n\n        ret_intr_type = RTAS_TYPE_MSIX;\n\n        break;\n\n    default:\n\n        error_report(\"rtas_ibm_change_msi(%u) is not implemented\", func);\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Fins sPAPRPHBState */\n\n    phb = spapr_pci_find_phb(spapr, buid);\n\n    if (phb) {\n\n        pdev = spapr_pci_find_dev(spapr, buid, config_addr);\n\n    }\n\n    if (!phb || !pdev) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Releasing MSIs */\n\n    if (!req_num) {\n\n        msi = (spapr_pci_msi *) g_hash_table_lookup(phb->msi, &config_addr);\n\n        if (!msi) {\n\n            trace_spapr_pci_msi(\"Releasing wrong config\", config_addr);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        xics_free(spapr->icp, msi->first_irq, msi->num);\n\n        if (msi_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, false, 0, num);\n\n        }\n\n        if (msix_present(pdev)) {\n\n            spapr_msi_setmsg(pdev, 0, true, 0, num);\n\n        }\n\n        g_hash_table_remove(phb->msi, &config_addr);\n\n\n\n        trace_spapr_pci_msi(\"Released MSIs\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        rtas_st(rets, 1, 0);\n\n        return;\n\n    }\n\n\n\n    /* Enabling MSI */\n\n\n\n    /* Check if the device supports as many IRQs as requested */\n\n    if (ret_intr_type == RTAS_TYPE_MSI) {\n\n        max_irqs = msi_nr_vectors_allocated(pdev);\n\n    } else if (ret_intr_type == RTAS_TYPE_MSIX) {\n\n        max_irqs = pdev->msix_entries_nr;\n\n    }\n\n    if (!max_irqs) {\n\n        error_report(\"Requested interrupt type %d is not enabled for device %x\",\n\n                     ret_intr_type, config_addr);\n\n        rtas_st(rets, 0, -1); /* Hardware error */\n\n        return;\n\n    }\n\n    /* Correct the number if the guest asked for too many */\n\n    if (req_num > max_irqs) {\n\n        trace_spapr_pci_msi_retry(config_addr, req_num, max_irqs);\n\n        req_num = max_irqs;\n\n        irq = 0; /* to avoid misleading trace */\n\n        goto out;\n\n    }\n\n\n\n    /* Allocate MSIs */\n\n    irq = xics_alloc_block(spapr->icp, 0, req_num, false,\n\n                           ret_intr_type == RTAS_TYPE_MSI);\n\n    if (!irq) {\n\n        error_report(\"Cannot allocate MSIs for device %x\", config_addr);\n\n        rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* Setup MSI/MSIX vectors in the device (via cfgspace or MSIX BAR) */\n\n    spapr_msi_setmsg(pdev, SPAPR_PCI_MSI_WINDOW, ret_intr_type == RTAS_TYPE_MSIX,\n\n                     irq, req_num);\n\n\n\n    /* Add MSI device to cache */\n\n    msi = g_new(spapr_pci_msi, 1);\n\n    msi->first_irq = irq;\n\n    msi->num = req_num;\n\n    config_addr_key = g_new(int, 1);\n\n    *config_addr_key = config_addr;\n\n    g_hash_table_insert(phb->msi, config_addr_key, msi);\n\n\n\nout:\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, req_num);\n\n    rtas_st(rets, 2, ++seq_num);\n\n    if (nret > 3) {\n\n        rtas_st(rets, 3, ret_intr_type);\n\n    }\n\n\n\n    trace_spapr_pci_rtas_ibm_change_msi(config_addr, func, req_num, irq);\n\n}\n", "idx": 62}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    char buf[256];\n\n    char *p;\n\n    target_ulong addr;\n\n    uint64_t i64;\n\n    GDBState *s;\n\n\n\n    s = gdbserver_state;\n\n    if (!s)\n\n        return;\n\n    gdb_current_syscall_cb = cb;\n\n    s->state = RS_SYSCALL;\n\n#ifndef CONFIG_USER_ONLY\n\n    vm_stop(EXCP_DEBUG);\n\n#endif\n\n    s->state = RS_IDLE;\n\n    va_start(va, fmt);\n\n    p = buf;\n\n    *(p++) = 'F';\n\n    while (*fmt) {\n\n        if (*fmt == '%') {\n\n            fmt++;\n\n            switch (*fmt++) {\n\n            case 'x':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx, addr);\n\n                break;\n\n            case 'l':\n\n                if (*(fmt++) != 'x')\n\n                    goto bad_format;\n\n                i64 = va_arg(va, uint64_t);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, \"%\" PRIx64, i64);\n\n                break;\n\n            case 's':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx \"/%x\",\n\n                              addr, va_arg(va, int));\n\n                break;\n\n            default:\n\n            bad_format:\n\n                fprintf(stderr, \"gdbstub: Bad syscall format string '%s'\\n\",\n\n                        fmt - 1);\n\n                break;\n\n            }\n\n        } else {\n\n            *(p++) = *(fmt++);\n\n        }\n\n    }\n\n    *p = 0;\n\n    va_end(va);\n\n    put_packet(s, buf);\n\n#ifdef CONFIG_USER_ONLY\n\n    gdb_handlesig(s->c_cpu, 0);\n\n#else\n\n    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);\n\n#endif\n\n}\n", "idx": 71}
{"project": "qemu", "commit_id": "df1561e22df42643d769aacdcc7d6d239f243366", "target": 0, "func": "static void gen_cp0 (CPUState *env, DisasContext *ctx, uint32_t opc, int rt, int rd)\n\n{\n\n    const char *opn = \"ldst\";\n\n\n\n    switch (opc) {\n\n    case OPC_MFC0:\n\n        if (rt == 0) {\n\n            /* Treat as NOP */\n\n            return;\n\n        }\n\n        gen_mfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"mfc0\";\n\n        break;\n\n    case OPC_MTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_mtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"mtc0\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case OPC_DMFC0:\n\n        if (rt == 0) {\n\n            /* Treat as NOP */\n\n            return;\n\n        }\n\n        gen_dmfc0(ctx, rd, ctx->opcode & 0x7);\n\n        gen_op_store_T0_gpr(rt);\n\n        opn = \"dmfc0\";\n\n        break;\n\n    case OPC_DMTC0:\n\n        GEN_LOAD_REG_TN(T0, rt);\n\n        gen_dmtc0(ctx, rd, ctx->opcode & 0x7);\n\n        opn = \"dmtc0\";\n\n        break;\n\n#endif\n\n    case OPC_TLBWI:\n\n        opn = \"tlbwi\";\n\n        if (!env->do_tlbwi)\n\n            goto die;\n\n        gen_op_tlbwi();\n\n        break;\n\n    case OPC_TLBWR:\n\n        opn = \"tlbwr\";\n\n        if (!env->do_tlbwr)\n\n            goto die;\n\n        gen_op_tlbwr();\n\n        break;\n\n    case OPC_TLBP:\n\n        opn = \"tlbp\";\n\n        if (!env->do_tlbp)\n\n            goto die;\n\n        gen_op_tlbp();\n\n        break;\n\n    case OPC_TLBR:\n\n        opn = \"tlbr\";\n\n        if (!env->do_tlbr)\n\n            goto die;\n\n        gen_op_tlbr();\n\n        break;\n\n    case OPC_ERET:\n\n        opn = \"eret\";\n\n        save_cpu_state(ctx, 0);\n\n        gen_op_eret();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    case OPC_DERET:\n\n        opn = \"deret\";\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            MIPS_INVAL(opn);\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            save_cpu_state(ctx, 0);\n\n            gen_op_deret();\n\n            ctx->bstate = BS_EXCP;\n\n        }\n\n        break;\n\n    case OPC_WAIT:\n\n        opn = \"wait\";\n\n        /* If we get an exception, we want to restart at next instruction */\n\n        ctx->pc += 4;\n\n        save_cpu_state(ctx, 1);\n\n        ctx->pc -= 4;\n\n        gen_op_wait();\n\n        ctx->bstate = BS_EXCP;\n\n        break;\n\n    default:\n\n die:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    MIPS_DEBUG(\"%s %s %d\", opn, regnames[rt], rd);\n\n}\n", "idx": 75}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void tricore_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    TriCoreCPU *cpu = TRICORE_CPU(obj);\n\n    CPUTriCoreState *env = &cpu->env;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        tricore_tcg_init();\n\n    }\n\n}\n", "idx": 88}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag)\n\n{\n\n    switch (tag) {\n\n    case 0x1901:\n\n        mxf->packages_count = get_be32(pb);\n\n        if (mxf->packages_count >= UINT_MAX / sizeof(UID))\n\n            return -1;\n\n        mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID));\n\n        if (!mxf->packages_refs)\n\n            return -1;\n\n        url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */\n\n        get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID));\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 125}
{"project": "FFmpeg", "commit_id": "c3e6e8f06c42499bd020fd0b37f9542150e6067b", "target": 0, "func": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n\n{\n\n    void **ptrptr = ptr;\n\n    void *ret;\n\n    if (size <= 0 || nmemb >= INT_MAX / size)\n\n        return AVERROR(ENOMEM);\n\n    if (nmemb <= 0) {\n\n        av_freep(ptr);\n\n        return 0;\n\n    }\n\n    ret = av_realloc(*ptrptr, nmemb * size);\n\n    if (!ret) {\n\n        av_freep(ptr);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    *ptrptr = ret;\n\n    return 0;\n\n}\n", "idx": 127}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_16w_msa(src - 2,\n\n                            src - (stride * 2) +\n\n                            sizeof(uint8_t), stride, dst, stride, 16);\n\n}\n", "idx": 137}
{"project": "qemu", "commit_id": "35f754620615138aaae0ef72602f84c88fd8de0f", "target": 1, "func": "struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n\n    return NULL;\n\n}", "idx": 143}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,\n\n                    ptrdiff_t stride, int h)\n\n{\n\n    const uint8_t *scantable = s->intra_scantable.permutated;\n\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n\n    int i, last, run, bits, level, start_i;\n\n    const int esc_length = s->ac_esc_length;\n\n    uint8_t *length, *last_length;\n\n\n\n    av_assert2(h == 8);\n\n\n\n    s->pdsp.diff_pixels(temp, src1, src2, stride);\n\n\n\n    s->block_last_index[0 /* FIXME */] =\n\n    last                               =\n\n        s->fast_dct_quantize(s, temp, 0 /* FIXME */, s->qscale, &i);\n\n\n\n    bits = 0;\n\n\n\n    if (s->mb_intra) {\n\n        start_i     = 1;\n\n        length      = s->intra_ac_vlc_length;\n\n        last_length = s->intra_ac_vlc_last_length;\n\n        bits       += s->luma_dc_vlc_length[temp[0] + 256]; // FIXME: chroma\n\n    } else {\n\n        start_i     = 0;\n\n        length      = s->inter_ac_vlc_length;\n\n        last_length = s->inter_ac_vlc_last_length;\n\n    }\n\n\n\n    if (last >= start_i) {\n\n        run = 0;\n\n        for (i = start_i; i < last; i++) {\n\n            int j = scantable[i];\n\n            level = temp[j];\n\n\n\n            if (level) {\n\n                level += 64;\n\n                if ((level & (~127)) == 0)\n\n                    bits += length[UNI_AC_ENC_INDEX(run, level)];\n\n                else\n\n                    bits += esc_length;\n\n                run = 0;\n\n            } else\n\n                run++;\n\n        }\n\n        i = scantable[last];\n\n\n\n        level = temp[i] + 64;\n\n\n\n        av_assert2(level - 64);\n\n\n\n        if ((level & (~127)) == 0)\n\n            bits += last_length[UNI_AC_ENC_INDEX(run, level)];\n\n        else\n\n            bits += esc_length;\n\n    }\n\n\n\n    return bits;\n\n}\n", "idx": 146}
{"project": "qemu", "commit_id": "3e4f910c8d490a1490409a7e381dbbb229f9d272", "target": 1, "func": "static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    fprintf(stderr, \"EHCI doesn't handle 16-bit writes to MMIO\\n\");\n\n    exit(1);\n\n}\n", "idx": 155}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void xendev_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->props = xendev_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n\n\n\n\n\n}", "idx": 161}
{"project": "qemu", "commit_id": "1fa795a853255fcc93e5d3e2a92d161a2ed96eb8", "target": 1, "func": "static uint64_t qdev_get_prop_mask64(Property *prop)\n\n{\n\n    assert(prop->info == &qdev_prop_bit);\n\n    return 0x1 << prop->bitnr;\n\n}\n", "idx": 162}